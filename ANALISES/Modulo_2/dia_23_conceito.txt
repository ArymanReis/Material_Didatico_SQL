Vamos então para o Dia 23 do nosso cronograma: um tópico teórico, mas que vai clarear muitas coisas para você e te salvar de futuras dores de cabeça: A Ordem Lógica de Execução do SQL.

Módulo 2 / Dia 23: A Ordem Lógica do SQL
Até agora, nós aprendemos a escrever nossas consultas em uma ordem específica, que é a ordem que a sintaxe do SQL exige. Mas você sabia que o banco de dados não lê ou executa os comandos nessa ordem?

Entender a ordem de "pensamento" do banco é um superpoder para resolver erros e entender por que certas consultas funcionam e outras não.

A Ordem que Escrevemos:

SELECT

FROM

WHERE

GROUP BY

HAVING

ORDER BY

A Ordem que o Banco Executa (A Ordem Lógica):
Pense no banco de dados preparando um grande jantar:

FROM: Primeiro, ele vai à despensa e pega as tabelas que vai usar. É o passo de "separar os ingredientes principais".

WHERE: Em seguida, ele olha para cada ingrediente individualmente (cada linha) e joga fora os que não atendem ao critério. (Ex: "só quero os tomates maduros"). Ele filtra as LINHAS.

GROUP BY: Com os ingredientes que sobraram, ele os agrupa em potes separados. (Ex: "um pote para os tomates, um para as cebolas, um para os pimentões"). Ele cria os GRUPOS.

HAVING: Agora, ele olha para os potes já agrupados e joga fora os potes que não lhe interessam. (Ex: "só quero os potes que tenham mais de 5 ingredientes dentro"). Ele filtra os GRUPOS.

SELECT: Só agora, com tudo filtrado e agrupado, ele decide o que vai mostrar no prato final. (Ex: "vou mostrar o nome do ingrediente e quantos tem em cada pote"). É aqui que os cálculos como COUNT(), SUM() e os apelidos (AS) são processados.

ORDER BY: Por último, ele organiza os pratos na mesa de exibição para a apresentação final (em ordem alfabética, do maior para o menor, etc.).

Por que isso é tão importante? (O "Pulo do Gato")
Lembra que usamos AS para criar apelidos para as colunas, como COUNT(*) AS Total_de_Lotes?

Você não pode usar o apelido Total_de_Lotes em uma cláusula WHERE ou HAVING.

Exemplo que dá ERRO:
... HAVING Total_de_Lotes > 1;

Por quê? Porque o WHERE e o HAVING (passos 2 e 4) são executados ANTES do SELECT (passo 5). Quando o WHERE e o HAVING estão rodando, o apelido Total_de_Lotes ainda não foi criado, ele não existe! É por isso que você precisa repetir a função: HAVING COUNT(*) > 1.

Este é um dia teórico. Não temos um exercício de código, mas sim de fixação.

Pergunta para Refletir:
Com base no que vimos, se você quisesse filtrar apenas os resultados onde a contagem de fazendas por estado é maior que 2, você usaria WHERE ou HAVING? E por quê, pensando na ordem de execução?

Resposta: HAVING; O WHERE atua nas "linhas brutas" antes de qualquer cálculo de agrupamento, e o HAVING atua nos "grupos já calculados", quando a contagem (COUNT) já existe e pode ser usada como condição.

